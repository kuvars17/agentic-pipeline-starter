"""Conversation state management using Pydantic models.

This module provides the core ConversationState model that serves as the
shared memory and state management system for the entire agentic pipeline.
"""

from datetime import datetime
from typing import Any, Dict, List, Optional, Union
from uuid import UUID, uuid4

from pydantic import BaseModel, Field, validator


class ConversationState(BaseModel):
    """Core conversation state that tracks the agentic reasoning process.
    
    This model serves as the central memory system for the agentic pipeline,
    tracking user queries, generated plans, collected evidence, judgments,
    and final answers throughout the reasoning process.
    
    Attributes:
        conversation_id: Unique identifier for this conversation
        query: The original user query/question
        plan: List of steps generated by the Planner node
        evidence: Dictionary of evidence collected by the Toolbox node
        answer: Final answer generated by the Reporter node
        verdict: Quality assessment from the Judge node
        errors: List of any errors encountered during processing
        metadata: Additional metadata for tracking and debugging
        created_at: Timestamp when the conversation was created
        updated_at: Timestamp when the conversation was last updated
    """
    
    # Core identification
    conversation_id: UUID = Field(
        default_factory=uuid4,
        description="Unique identifier for this conversation"
    )
    
    # User input
    query: str = Field(
        ...,
        description="The original user query or question",
        min_length=1,
        max_length=10000
    )
    
    # Processing stages
    plan: List[str] = Field(
        default_factory=list,
        description="List of steps generated by the Planner node"
    )
    
    evidence: Dict[str, Union[str, Dict[str, Any]]] = Field(
        default_factory=dict,
        description="Evidence collected by the Toolbox node"
    )
    
    verdict: Optional[str] = Field(
        default=None,
        description="Quality assessment from the Judge node"
    )
    
    answer: Optional[str] = Field(
        default=None,
        description="Final answer generated by the Reporter node"
    )
    
    # Error tracking
    errors: List[str] = Field(
        default_factory=list,
        description="List of errors encountered during processing"
    )
    
    # Metadata and tracking
    metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="Additional metadata for tracking and debugging"
    )
    
    created_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Timestamp when the conversation was created"
    )
    
    updated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Timestamp when the conversation was last updated"
    )
    
    class Config:
        """Pydantic configuration."""
        json_encoders = {
            datetime: lambda v: v.isoformat(),
            UUID: lambda v: str(v)
        }
        schema_extra = {
            "example": {
                "conversation_id": "123e4567-e89b-12d3-a456-426614174000",
                "query": "What is the capital of Germany?",
                "plan": [
                    "Search for information about Germany's capital",
                    "Verify the information from reliable sources",
                    "Provide a comprehensive answer"
                ],
                "evidence": {
                    "search_result": "Berlin is the capital of Germany",
                    "source": "https://example.com/germany-info"
                },
                "verdict": "High confidence: Information is accurate and well-sourced",
                "answer": "The capital of Germany is Berlin.",
                "errors": [],
                "metadata": {
                    "processing_time": 2.5,
                    "nodes_executed": ["planner", "toolbox", "judge", "reporter"]
                }
            }
        }
    
    @validator('query')
    def validate_query(cls, v: str) -> str:
        """Validate the query is not empty or just whitespace."""
        if not v or not v.strip():
            raise ValueError("Query cannot be empty or just whitespace")
        return v.strip()
    
    @validator('plan')
    def validate_plan(cls, v: List[str]) -> List[str]:
        """Validate plan steps are meaningful."""
        validated_plan = []
        for step in v:
            if isinstance(step, str) and step.strip():
                validated_plan.append(step.strip())
        return validated_plan
    
    @validator('updated_at', always=True)
    def update_timestamp(cls, v: datetime, values: Dict[str, Any]) -> datetime:
        """Always update the timestamp when the model is modified."""
        return datetime.utcnow()
    
    def add_plan_step(self, step: str) -> None:
        """Add a new step to the plan.
        
        Args:
            step: The planning step to add
        """
        if step and step.strip():
            self.plan.append(step.strip())
            self.updated_at = datetime.utcnow()
    
    def add_evidence(self, key: str, value: Union[str, Dict[str, Any]]) -> None:
        """Add evidence collected during execution.
        
        Args:
            key: Evidence identifier/category
            value: Evidence data (string or structured data)
        """
        self.evidence[key] = value
        self.updated_at = datetime.utcnow()
    
    def add_error(self, error: str) -> None:
        """Add an error to the error list.
        
        Args:
            error: Error message or description
        """
        if error and error.strip():
            self.errors.append(error.strip())
            self.updated_at = datetime.utcnow()
    
    def set_verdict(self, verdict: str) -> None:
        """Set the judge's verdict on the evidence quality.
        
        Args:
            verdict: Quality assessment from the Judge node
        """
        self.verdict = verdict.strip() if verdict else None
        self.updated_at = datetime.utcnow()
    
    def set_answer(self, answer: str) -> None:
        """Set the final answer from the Reporter node.
        
        Args:
            answer: Final answer to the user's query
        """
        self.answer = answer.strip() if answer else None
        self.updated_at = datetime.utcnow()
    
    def update_metadata(self, key: str, value: Any) -> None:
        """Update metadata with additional tracking information.
        
        Args:
            key: Metadata key
            value: Metadata value
        """
        self.metadata[key] = value
        self.updated_at = datetime.utcnow()
    
    def is_complete(self) -> bool:
        """Check if the conversation has completed all processing stages.
        
        Returns:
            True if all stages are complete (has plan, evidence, verdict, answer)
        """
        return bool(
            self.plan and 
            self.evidence and 
            self.verdict is not None and 
            self.answer is not None
        )
    
    def has_errors(self) -> bool:
        """Check if any errors were encountered during processing.
        
        Returns:
            True if there are any errors in the error list
        """
        return len(self.errors) > 0
    
    def get_processing_summary(self) -> Dict[str, Any]:
        """Get a summary of the processing state.
        
        Returns:
            Dictionary with processing status information
        """
        return {
            "conversation_id": str(self.conversation_id),
            "query_length": len(self.query),
            "plan_steps": len(self.plan),
            "evidence_count": len(self.evidence),
            "has_verdict": self.verdict is not None,
            "has_answer": self.answer is not None,
            "error_count": len(self.errors),
            "is_complete": self.is_complete(),
            "processing_time": (self.updated_at - self.created_at).total_seconds()
        }


# Type aliases for better code readability
ConversationID = UUID
EvidenceDict = Dict[str, Union[str, Dict[str, Any]]]
PlanSteps = List[str]